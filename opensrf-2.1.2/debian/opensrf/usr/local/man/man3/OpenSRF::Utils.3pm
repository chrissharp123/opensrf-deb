.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OpenSRF::Utils 3pm"
.TH OpenSRF::Utils 3pm "2013-03-15" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenSRF::Utils
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a container package for methods that are useful to derived modules.
It has no constructor, and is generally not useful by itself... but this
is where most of the generic methods live.
.SH "VERSION"
.IX Header "VERSION"
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$thing\->encrypt(@stuff)"
.el .SS "\f(CW$thing\fP\->encrypt(@stuff)"
.IX Subsection "$thing->encrypt(@stuff)"
Returns a one way hash (\s-1MD5\s0) of the values appended together.
.ie n .SS "$utils_obj\->es_time('field') \s-1OR\s0 noo_es_time($timestamp)"
.el .SS "\f(CW$utils_obj\fP\->es_time('field') \s-1OR\s0 noo_es_time($timestamp)"
.IX Subsection "$utils_obj->es_time('field') OR noo_es_time($timestamp)"
Returns the epoch-second style timestamp for the value stored in
\&\f(CW$utils_obj\fR\->{field}.  Returns \fB0\fR for an empty or invalid date stamp, and
assumes a PostgreSQL style datestamp to be supplied.
.SS "noo_es_time($timestamp) (non-OO es_time)"
.IX Subsection "noo_es_time($timestamp) (non-OO es_time)"
Returns the epoch-second style timestamp for the \fB\f(CB$timestamp\fB\fR passed
in.  Returns \fB0\fR for an empty or invalid date stamp, and
assumes a PostgreSQL style datestamp to be supplied.
.ie n .SS "$thing\->interval_to_seconds('interval') \s-1OR\s0 interval_to_seconds('interval')"
.el .SS "\f(CW$thing\fP\->interval_to_seconds('interval') \s-1OR\s0 interval_to_seconds('interval')"
.IX Subsection "$thing->interval_to_seconds('interval') OR interval_to_seconds('interval')"
.ie n .SS "$thing\->seconds_to_interval($seconds) \s-1OR\s0 seconds_to_interval($seconds)"
.el .SS "\f(CW$thing\fP\->seconds_to_interval($seconds) \s-1OR\s0 seconds_to_interval($seconds)"
.IX Subsection "$thing->seconds_to_interval($seconds) OR seconds_to_interval($seconds)"
Returns the number of seconds for any interval passed, or the interval for the seconds.
This is the generic version of \fBinterval\fR listed below.
.PP
The interval must match the regex \fI/\es*\e+?\es*(\ed+)\es*(\ew{1})\ew*\es*/g\fR, for example
\&\fB2 weeks, 3 d and 1hour + 17 Months\fR or
\&\fB1 year, 5 Months, 2 weeks, 3 days and 1 hour of seconds\fR meaning 46148400 seconds.
.PP
.Vb 1
\&        my $expire_time = time() + $thing\->interval_to_seconds(\*(Aq17h 9m\*(Aq);
.Ve
.PP
The time size indicator may be one of
.IP "s[econd[s]]" 2
.IX Item "s[econd[s]]"
for seconds
.IP "m[inute[s]]" 2
.IX Item "m[inute[s]]"
for minutes
.IP "h[our[s]]" 2
.IX Item "h[our[s]]"
for hours
.IP "d[ay[s]]" 2
.IX Item "d[ay[s]]"
for days
.IP "w[eek[s]]" 2
.IX Item "w[eek[s]]"
for weeks
.IP "M[onth[s]]" 2
.IX Item "M[onth[s]]"
for months (really (365 * 1d)/12 ... that may get smarter, though)
.IP "y[ear[s]]" 2
.IX Item "y[ear[s]]"
for years (this is 365 * 1d)
.ie n .SS "$utils_obj\->set_psname('string') \s-1OR\s0 set_psname('string')"
.el .SS "\f(CW$utils_obj\fP\->set_psname('string') \s-1OR\s0 set_psname('string')"
.IX Subsection "$utils_obj->set_psname('string') OR set_psname('string')"
Sets the name of this process in a \fBps\fR listing to \fBstring\fR.
.ie n .SS "$utils_obj\->daemonize('ps_name') \s-1OR\s0 daemonize('ps_name')"
.el .SS "\f(CW$utils_obj\fP\->daemonize('ps_name') \s-1OR\s0 daemonize('ps_name')"
.IX Subsection "$utils_obj->daemonize('ps_name') OR daemonize('ps_name')"
Turns the current process into a daemon.  \fBps_name\fR is optional, and is used
as the argument to \fI\fIset_psname()\fI\fR if passed.
.ie n .SS "$utils_obj\->safe_fork('ps_name') \s-1OR\s0 safe_fork('ps_name');"
.el .SS "\f(CW$utils_obj\fP\->safe_fork('ps_name') \s-1OR\s0 safe_fork('ps_name');"
.IX Subsection "$utils_obj->safe_fork('ps_name') OR safe_fork('ps_name');"
Forks the current process in a retry loop.  \fBps_name\fR is optional, and is used
as the argument to \fI\fIset_psname()\fI\fR if passed.
