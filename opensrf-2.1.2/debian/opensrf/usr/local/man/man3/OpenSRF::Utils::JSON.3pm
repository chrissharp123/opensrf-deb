.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OpenSRF::Utils::JSON 3pm"
.TH OpenSRF::Utils::JSON 3pm "2013-03-15" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenSRF::Utils::JSON \- Serialize/Vivify objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\f(CW\*(C`O::U::JSON\*(C'\fR is a functional-style package which exports nothing. All
calls to routines must use the fully-qualified name, and expect an
invocant, as in
.PP
.Vb 1
\&    OpenSRF::Utils::JSON\->JSON2perl($string);
.Ve
.PP
The routines which are called by existing external code all deal with
the serialization/stringification of objects and their revivification.
.SH "ROUTINES"
.IX Header "ROUTINES"
.SS "register_class_hint"
.IX Subsection "register_class_hint"
This routine is used by objects which wish to serialize themselves
with the \*(L"perl2JSON\*(R" routine. It has two required arguments, \f(CW\*(C`name\*(C'\fR
and \f(CW\*(C`hint\*(C'\fR.
.PP
.Vb 2
\&    O::U::J\->register_class_hint( hint => \*(AqosrfException\*(Aq,
\&                                  name => \*(AqOpenSRF::DomainObject::oilsException\*(Aq);
.Ve
.PP
Where \f(CW\*(C`hint\*(C'\fR can be any unique string (but canonically is the name
from the \s-1IDL\s0 which matches the object being operated on), and \f(CW\*(C`name\*(C'\fR
is the language-specific classname which objects will be revivified
as.
.SS "JSON2perl"
.IX Subsection "JSON2perl"
Given a JSON-encoded string, returns a vivified Perl object built from
that string.
.SS "perl2JSON"
.IX Subsection "perl2JSON"
Given a Perl object, returns a \s-1JSON\s0 stringified representation of that
object.
.SH "INTERNAL ROUTINES"
.IX Header "INTERNAL ROUTINES"
.SS "rawJSON2perl"
.IX Subsection "rawJSON2perl"
Performs actual \s-1JSON\s0 \-> data transformation, before
\&\*(L"JSONObject2Perl\*(R" is called.
.SS "rawPerl2JSON"
.IX Subsection "rawPerl2JSON"
Performs actual data \-> \s-1JSON\s0 transformation, after \*(L"perl2JSONObject\*(R"
has been called.
.SS "JSONObject2Perl"
.IX Subsection "JSONObject2Perl"
Routine called by \*(L"JSON2perl\*(R" after \*(L"rawJSON2perl\*(R" is called.
.PP
At this stage, the \s-1JSON\s0 string will have been vivified as data. This
routine's job is to turn it back into an OpenSRF system object of some
sort, if possible.
.PP
If it's not possible, the original data (structure), or one very much
like it will be returned.
.SS "perl2JSONObject"
.IX Subsection "perl2JSONObject"
Routine called by \*(L"perl2JSON\*(R" before \*(L"rawPerl2JSON\*(R" is called.
.PP
For OpenSRF system objects which have had hints about their classes
stowed via \*(L"register_class_hint\*(R", this routine acts as a wrapper,
encapsulating the incoming object in metadata about itself. It is not
unlike the process of encoding \s-1IP\s0 datagrams.
.PP
The only metadata encoded at the moment is the class hint, which is
used to reinflate the data as an object of the appropriate type in the
\&\*(L"JSONObject2perl\*(R" routine.
.PP
Other forms of data more-or-less come out as they went in, although
\&\f(CW\*(C`CODE\*(C'\fR or \f(CW\*(C`SCALAR\*(C'\fR references will return what looks like an OpenSRF
packet, but with a class hint of their reference type and an \f(CW\*(C`undef\*(C'\fR
payload.
.SS "lookup_class"
.IX Subsection "lookup_class"
Given a class hint, returns the classname matching it. Returns undef
on failure.
.SS "lookup_hint"
.IX Subsection "lookup_hint"
Given a classname, returns the class hint matching it. Returns undef
on failure.
.SS "true"
.IX Subsection "true"
Wrapper for JSON::XS::true. J::X::true and J::X::false, according to
its documentation, \*(L"are \s-1JSON\s0 atoms become JSON::XS::true and
JSON::XS::false, respectively. They are overloaded to act almost
exactly like the numbers 1 and 0\*(R"
.SS "false"
.IX Subsection "false"
See \*(L"true\*(R"
